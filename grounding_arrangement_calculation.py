# -*- coding: utf-8 -*-
"""
Расчёт сопротивления заземляющего устройства
"""
import math
import dboperations
import numpy as np


class GroundingArrangement:
    """Заземляющее устройство"""
    def __init__(self):
        self.Kивзмпр = 0.6  # Kивзм – коэффициент использования вертикальных электродов предварительный

        self.mode = None  # Режим вычислений (0 - проеверка, 1 - расчёт)
        self.H1 = None  # H1 - толщина верхнего слоя грунта
        self.ρ1 = None  # ρ1 - удельное сопротивление верхнего слоя грунта
        self.ρ2 = None  # ρ2 - удельное сопротивление нижнего слоя грунта
        self.ground_electrode_vertical_type = None  #
        self.dв = None  # dв - диаметр (или ширина) вертикального электрода
        self.dг = None  # dг - диаметр (или ширина) горизонтального электрода
        self.T = None  # T - глубина расположения горизонтального электрода
        self.contoured = None  # Расположение вертикальных заземлителей

        self.rдопзм = None  # rдопзм - Нормируемое сопротивление растеканию тока в землю (допустимое при данном грунте)
        self.Rе = None  # Rе - Сопротивление естественного заземлятеля
        self.t = None  # t - глубина заложения вертикального электрода
        self.Lв = None  # Lв - высота вертикального электрода
        self.Rво = None  # Rв - сопротивление одного вертикального электрода
        self.Kв = None  # Кв – поправочный коэффициент (для вертикальных заземлителей), учитывающий изменение удельного сопротивления грунта в зависимости от климатического района
        self.Kг = None  # Кг – поправочный коэффициент (для горизонтальных заземлителей), учитывающий изменение удельного сопротивления грунта в зависимости от климатического района
        self.Kивзм = None  # Kивзм – коэффициент использования вертикальных электродов (без учета влияния полосы связи) (см. табл.8­5 справочника)
        self.Kигзм = None  # Kигзм – коэффициент использования горизонтальных электродов (см. табл.8­6, 8-7 справочника)
        self.nпр = None  # nпр - примерное число вертикальных заземлителей при предварительно принятом коэф. использования
        self.n_уточн = None  # n_уточн - уточнённое число вертикальных заземлителей
        self.k_Lг_to_Lв = None  # k - предварительное отношение расстояния между электродами к длине электрода
        self.Lг = None  # Длина горизонтального заземлителя (суммарная для контурного заземлителя)
        self.Lг_A = None  # Длина горизонтального заземлителя (A, длина контура заземления)
        self.Lг_B = None  # Ширина контура заземления (B, только для контурного)

        self.Rи = None  # Rи - Сопротивление искуственного заземлятеля
        self.ρэкв = None  # ρэкв - эквивалентное удельное электрическое сопротивление двухслойного грунта
        self.ρрасчв = None  # ρрасчв - расчётное эквивалентное удельное электрическое сопротивление грунта для вертикальных электродов
        self.ρрасчг = None  # ρрасчг - расчётное эквивалентное удельное электрическое сопротивление грунта для горизонтальных электродов
        self.dвэкв = None  # dвэкв - эквивалентный диаметр вертикального электрода
        self.Rзв = None  # Rзв - Результирующее сопротивление части заземлителя, состоящей из вертикальных электродов, электрически связанных между собой, без учета сопротивления соединяющей их полосы, с учетом экранирования и климатического района
        self.Rг = None  # Rг - Сопротивление горизонтального заземлителя, с учетом экранирования и климатического района
        self.Rв_уточн = None  # Rв_уточн - Уточнённое значение сопротивления вертикального заземлителя
        self.Rз = None  # Rз - Полное сопротивление растеканию заземляющего устройства
        self.result = None  # Удовлетворение требования нормативной документации

    @property
    def ro_eq(self):
        """Get the current ro_eq"""
        return self.ρэкв

    @ro_eq.setter
    def ro_eq(self, value):
        # assert isinstance(value, float)
        self.ρэкв = value

    def calc_Rи(self):  # Rи
        """
        Расчёт необходимого сопротивления искусственного заземлителя с учётом использования естественных заземлителей
        - Rи
        """
        if self.Rе and self.rдопзм:
            self.Rи = self.Rе * self.rдопзм / (self.Rе - self.rдопзм)
        else:
            self.Rи = self.rдопзм

    def calc_t(self):  # t
        """
        Расчёт глубины заложения вертикального электрода - t
        Cчитается расстояние от поверхности земли до середины электрода
        Lв - высота вертикального электрода
        T - глубина расположения горизонтального электрода
        """
        self.t = 1/2 * self.Lв + self.T

    def calc_ρэкв(self):
        """
        Расчёт эквивалентного удельного электрического сопротивления двухслойного грунта - ρэкв
        ρ1 - удельное сопротивление верхнего слоя грунта
        ρ2 - удельное сопротивление нижнего слоя грунта
        Lв - высота вертикального электрода
        T - глубина расположения горизонтального электрода
        H1 - толщина верхнего слоя грунта
        """
        if self.ρ1 and self.ρ2 and self.H1:
            self.ρэкв = self.ρ1 * self.ρ2 * self.Lв / (self.ρ1 * (self.Lв + self.T - self.H1) + self.ρ2 * (self.H1 - self.T))
        else:
            self.ρэкв = self.ρ1

    def calc_ρрасчв(self):
        """
        Расчёт расчётного эквивалентного удельного электрического сопротивления грунта для вертикальных электродов
        :param ρэкв:
        :param Kв:
        :return:
        """
        self.ρрасчв = self.ρэкв * self.Kв

    def calc_ρрасчг(self):
        """
        Расчёт расчётного эквивалентного удельного электрического сопротивления грунта для вертикальных электродов
        :param ρэкв:
        :param Kг:
        :return:
        """
        self.ρрасчг = self.ρэкв * self.Kг

    def calc_dвэкв(self):
        """
        Эквивалентный диаметр уголка
        :param d:
        :return:
        """
        if self.ground_electrode_vertical_type:
            self.dвэкв = 0.95 * self.dв
        else:
            self.dвэкв = self.dв

    def calc_Rво(self):
        """
        Сопротивление одного вертикального электрода - Rво
        ρ - удельное сопротивление грунта
        Lв - высота вертикального электрода
        t - глубина заложения вертикального электрода
        dв - диаметр вертикального электрода
        """
        self.Rво = (self.ρрасчв / (2 * math.pi * self.Lв)) * \
                   (math.log(2*self.Lв/self.dв) + 1/2 * math.log((4*self.t + self.Lв)/(4*self.t - self.Lв)))

    def calc_nпр(self):
        """
        Расчёт примерного числа вертикальных заземлителей при предварительно принятом коэф. использования
        :param Rво:
        :param Kв:
        :param rизм:
        :return:
        """
        self.nпр = math.ceil(self.Rво / (self.Kивзмпр * self.Rи))

    def calc_k_Lг_to_Lв(self):
        """
        Расчёт предварительного отношения расстояния между электродами к длине электрода
        :param Lв:
        :param nпр:
        :param L:
        :param Lг_A:
        :return:
        """
        if not self.mode:
            self.k_Lг_to_Lв = math.floor(self.Lг / (self.n_уточн * self.Lв))

    def calc_Lг(self):
        """
        Расчёт длины горизонтального заземлителя (суммарная для контурного заземлителя)
        :param Lг_A:
        :param LгB:
        :return:
        """
        if self.mode:
            self.Lг = self.k_Lг_to_Lв * self.nпр * self.Lв
        else:
            if self.contoured:
                self.Lг = 2 * (self.Lг_A + self.Lг_B)
            else:
                self.Lг = self.Lг_A

    def calc_Kивзм(self, n):
        """
        Вычисление Kивзм
        :return:
        """
        if self.contoured:
            table = dboperations.find_table_8_5(self.k_Lг_to_Lв if self.k_Lг_to_Lв >= 1 else 1)
        else:
            table = dboperations.find_table_8_4(self.k_Lг_to_Lв if self.k_Lг_to_Lв >= 1 else 1)
        self.Kивзм = np.interp(n, table[0], table[1])
        # self.Kивзм = 0.24

    def calc_Kигзм(self, n):
        """
        Вычисление Kигзм
        :return:
        """
        if self.contoured:
            table = dboperations.find_table_8_7(self.k_Lг_to_Lв if self.k_Lг_to_Lв >= 1 else 1)
        else:
            table = dboperations.find_table_8_6(self.k_Lг_to_Lв if self.k_Lг_to_Lв >= 1 else 1)
        self.Kигзм = np.interp(n, table[0], table[1])
        # self.Kигзм = 0.54

    def calc_Rг(self):
        """
        Сопротивление горизонтального электрода - Rг
        Lг - длина горизонтального электрода (суммарная)
        T - глубина заложения горизонтального электрода
        dг - диаметр горизонтального электрода
        """
        self.Rг = (1 / self.Kигзм) * self.ρрасчг / (2 * math.pi * self.Lг) * math.log(self.Lг**2 / (self.dг * self.T))

    def calc_Rв_уточн(self):  # Rв_уточн
        """
        Расчёт уточнённого значения Rв_уточн
        """
        if self.mode:
            self.Rв_уточн = self.Rг * self.Rи / (self.Rг - self.Rи)
        else:
            self.Rв_уточн = self.Rво / (self.Kивзм * self.n_уточн)

    def calc_n_уточн(self):
        """
        Расчёт примерного числа вертикальных заземлителей при предварительно принятом коэф. использования
        """
        self.n_уточн = math.ceil(self.Rво / (self.Kивзм * self.Rи))

    def calc_Rз(self):
        """
        Полное сопротивление растеканию заземляющего устройства - Rз
        """
        self.Rз = self.Rв_уточн * self.Rг / (self.Rв_уточн + self.Rг)

    def calc_result(self):
        """
        Удовлетворение требования нормативной документации
        """
        self.result = 'удовлетворяет' if self.Rз < self.Rи else 'не удовлетворяет'

    def calc_R(self):
        """
        Расчёт заземляющего устройства
        :return:
        """
        if self.mode:
            self.calc_Rи()
            self.calc_ρэкв()
            self.calc_ρрасчв()
            self.calc_ρрасчг()
            self.calc_t()
            self.calc_dвэкв()
            self.calc_Rво()
            self.calc_nпр()
            self.calc_k_Lг_to_Lв()
            self.calc_Kивзм(self.nпр)
            self.calc_Kигзм(self.nпр)
            self.calc_n_уточн()
            self.calc_Lг()
            self.calc_Rг()
            self.calc_Rв_уточн()
            self.calc_Rз()
        else:
            self.calc_Rи()
            self.calc_ρэкв()
            self.calc_ρрасчв()
            self.calc_ρрасчг()
            self.calc_t()
            self.calc_dвэкв()
            self.calc_Rво()
            self.calc_Lг()
            self.calc_k_Lг_to_Lв()
            self.calc_Kивзм(self.n_уточн)
            self.calc_Kигзм(self.n_уточн)
            self.calc_Rг()
            self.calc_Rв_уточн()
            self.calc_Rз()
            self.calc_result()
